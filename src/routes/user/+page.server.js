import { fail, redirect } from '@sveltejs/kit';
import { env } from '$env/dynamic/private';
import { eq, and } from 'drizzle-orm';
import { db } from '$lib/server/db';
import { inferenceModel, localModel, cloudModel, user, message } from '$lib/server/db/schema';

async function callCloudRun({
    cloudUrl,
    cloudKeyJsonString,
    path,
    method,
    body = null
}) {
    try {
        console.log("Attempting to call Cloud Run service:", cloudUrl + path); // Log target URL
        console.log("Using Cloud Key (first 50 chars):", cloudKeyJsonString.substring(0, 50) + '...'); // Log part of the key string

        const credentials = JSON.parse(cloudKeyJsonString);
        console.log("Credentials parsed successfully."); // Confirm parsing

        // 1. Instantiate GoogleAuth with credentials.
        const auth = new GoogleAuth({
            credentials,
        });
        console.log("GoogleAuth client created."); // Confirm auth creation

        // 2. Get the ID token client for the Cloud Run service URL (audience).
        // Log the audience being used
        console.log("Getting ID token client for audience:", cloudUrl);
        const client = await auth.getIdTokenClient(cloudUrl);
        console.log("ID token client obtained."); // Confirm client obtainment

        // 3. Get the headers, which will include the Authorization: Bearer <ID_TOKEN> header.
        const headers = await client.getRequestHeaders();
        console.log("Request headers generated by client:", headers); // <-- **Log the headers here**

        // 4. Construct the full URL.
        const fullUrl = `${cloudUrl}${path}`;

        // 5. Make the fetch request.
        console.log("Making fetch request to:", fullUrl);
        console.log("Fetch options:", {
            method: method,
            headers: {
                ...headers, // Include Authorization header
                'Content-Type': 'application/json',
            },
            body: body ? '[BODY PRESENT]' : '[NO BODY]', // Log body presence, not content for security
        });


        const response = await fetch(fullUrl, {
            method: method,
            headers: {
                ...headers, // Include Authorization header
                'Content-Type': 'application/json', // Assuming your endpoint expects JSON
            },
            body: body ? JSON.stringify(body) : undefined, // Stringify body if it exists
        });

        // Log the response status *before* checking response.ok
        console.log(`Workspace response received: ${response.status} ${response.statusText}`);

        // Check if the response indicates an error (like 403)
        if (!response.ok) {
            const errorBody = await response.text();
            console.error(`Cloud Run request failed (non-OK status): ${response.status} ${response.statusText}`, errorBody);
            throw new Error(`Cloud Run request failed: ${response.status} ${response.statusText}`);
        }
        console.log("Cloud Run request successful (OK status).");


        // Return the response object to be handled by the caller
        return response;

    } catch (error) {
        console.error('Error during callCloudRun execution:', error);
        // Do NOT re-throw here if you want the action to handle the fail() call
        // Instead, the action needs to check if callCloudRun returned a success or threw
        // Re-throwing for now, as your action expects it.
        throw error;
    }
}

export const load = async (event) => {
    const authUser = event.locals.user;
    if (!authUser) {
        redirect(302, '/login');
    }

    const allModels = await db.select().from(inferenceModel);

    const userLocalModels = await db.select()
        .from(localModel)
        .where(eq(localModel.userId, authUser.id));

    const userCloudModels = await db.select()
        .from(cloudModel)
        .where(eq(cloudModel.userId, authUser.id));

    const modelsWithStatus = allModels.map(model => ({
        ...model,
        localEnabled: userLocalModels.some(lm => lm.modelId === model.id),
        cloudEnabled: userCloudModels.some(cm => cm.modelId === model.id)
    }));

    const modelsGroupedByName = modelsWithStatus.reduce((accumulator, currentModel) => {
        const groupName = currentModel.name;
        const existingGroup = accumulator.find(group => group.modelName === groupName);

        if (!existingGroup) {
            accumulator.push({ modelName: groupName, models: [currentModel] });
        } else {
            existingGroup.models.push(currentModel);
        }
        return accumulator;
    }, []);
    return { models: modelsGroupedByName };
};

export const actions = {
    "toggle-model-local": async (event) => {
        const authUser = event.locals.user;
        if (!authUser) redirect(302, '/login');
        const formData = await event.request.formData();
        const modelId = Number(formData.get('modelId'));

        if (isNaN(modelId)) {
            return fail(400, { message: 'Invalid request' });
        }

        try {
            const userId = authUser.id;
            const existing = await db.select()
                .from(localModel)
                .where(and(
                    eq(localModel.userId, userId),
                    eq(localModel.modelId, modelId)
                ));

            if (existing.length) {
                const [wantedModel] = await db.select()
                    .from(inferenceModel)
                    .where(eq(inferenceModel.id, modelId));

                const responseToDelete = await fetch(`${env.OLLAMA_URL}/api/delete`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: wantedModel.ollamaName })
                });

                await db.delete(localModel)
                    .where(and(
                        eq(localModel.userId, userId),
                        eq(localModel.modelId, modelId)
                    ));
                return { success: true, message: 'Model succesfully removed from your machine.' };

            } else {
                const [wantedModel] = await db.select()
                    .from(inferenceModel)
                    .where(eq(inferenceModel.id, modelId));

                const response = await fetch(`${env.OLLAMA_URL}/api/pull`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: wantedModel.ollamaName })
                });

                const reader = response.body.getReader();
                while (true) {
                    const { done } = await reader.read();
                    if (done) break;
                }

                await db.insert(localModel).values({ userId, modelId });

                return {
                    success: true,
                    message: 'Model succesfully added from your machine.'
                };
            }
        } catch (error) {
            console.error(error);
            return fail(500, { message: 'Failed to update model status' });
        }
    },

    "toggle-model-cloud": async (event) => {
        const authUser = event.locals.user;
        if (!authUser) redirect(302, '/login');
        const formData = await event.request.formData();
        const modelId = Number(formData.get('modelId'));

        if (isNaN(modelId)) {
            return fail(400, { message: 'Invalid request' });
        }

        try {
            const userId = authUser.id;
            const [userData] = await db.select()
                .from(user)
                .where(eq(user.id, userId));

            if (!userData || !userData.cloudUrl || !userData.cloudKey) {
                 // Added more specific check
                 console.error("Missing cloud config for user:", userId);
                 return fail(400, { message: 'Cloud configuration (URL or Key) is missing for your account.' });
            }
            
            console.log("User data for cloud config loaded.");

            const [wantedModel] = await db.select()
                .from(inferenceModel)
                .where(eq(inferenceModel.id, modelId));

            if (!wantedModel) {
                 console.error("Model not found in DB:", modelId);
                 return fail(404, { message: 'Model not found.' });
            }
            console.log("Wanted model found:", wantedModel.ollamaName);


            const existing = await db.select()
                .from(cloudModel)
                .where(and(
                    eq(cloudModel.userId, userId),
                    eq(cloudModel.modelId, modelId)
                ));
            console.log(`Model ${wantedModel.name} ${existing.length ? 'exists' : 'does not exist'} in cloudModel for user ${userId}.`);


            if (existing.length) {
                // Model exists, so delete it
                console.log("Attempting to delete cloud model...");
                const responseToDelete = await callCloudRun({
                    cloudUrl: userData.cloudUrl,
                    cloudKeyJsonString: userData.cloudKey,
                    path: '/api/delete', // Adjust path as needed
                    method: 'DELETE',
                    body: { name: wantedModel.ollamaName }
                });
                console.log("Cloud Run delete call finished.");


                await db.delete(cloudModel)
                    .where(and(
                        eq(cloudModel.userId, userId),
                        eq(cloudModel.modelId, modelId)
                    ));
                console.log("Model removed from cloudModel DB table.");
                return { success: true, message: 'Model successfully removed from cloud.' };

            } else {
                // Model does not exist, so add it
                 console.log("Attempting to add cloud model...");
                 const response = await callCloudRun({
                    cloudUrl: userData.cloudUrl,
                    cloudKeyJsonString: userData.cloudKey,
                    path: '/api/pull', // Adjust path as needed
                    method: 'POST',
                    body: { name: wantedModel.ollamaName }
                });
                console.log("Cloud Run pull call finished.");


                // Handle streaming response if necessary, otherwise just proceed
                // Assuming for this purpose, a successful response from callCloudRun is enough
                // (since callCloudRun checks response.ok)

                await db.insert(cloudModel).values({ userId, modelId });
                 console.log("Model added to cloudModel DB table.");


                return {
                    success: true,
                    message: 'Model successfully added to cloud.'
                };
            }
        } catch (error) {
            console.error('Cloud model toggle action error caught:', error);
            if (error.message.startsWith('Cloud Run request failed:')) {
                 return fail(500, { message: `Cloud service error: ${error.message}` });
            }
            return fail(500, { message: `An unexpected error occurred: ${error.message}` });
        }
    },

    "update-cloud-info": async (event) => {
        const authUser = event.locals.user;
        if (!authUser) redirect(302, '/login');
        const formData = await event.request.formData();

        try {
            const cloudUrl = formData.get('cloud_url');
            const cloudKeyFile = formData.get('cloud_key');

            if (!cloudUrl || !cloudKeyFile || !(cloudKeyFile instanceof File)) {
                return fail(400, { message: 'Invalid request - missing required fields' });
            }

            const jsonContent = await cloudKeyFile.text();
            const cloudKeyData = JSON.parse(jsonContent);

            if (!cloudKeyData) {
                return fail(400, { message: 'Invalid JSON format - missing required fields' });
            }

            const userId = authUser.id;
            await db.update(user)
                .set({
                    cloudUrl: cloudUrl,
                    cloudKey: jsonContent
                })
                .where(eq(user.id, userId));

            return {
                success: true,
                message: 'Cloud configuration updated successfully'
            };
        } catch (error) {
            console.error('Cloud config update error:', error);
            return fail(500, {
                message: error instanceof SyntaxError
                    ? 'Invalid JSON file'
                    : 'Failed to update cloud configuration'
            });
        }
    }
};